нужно сделать так чтобы можно было подбирать алгоритмы для роккривой
13. уменьшить размер картинок и добавить обтикание через alt параметры

2. добавить пример кода в ридми
12. добавить потенциальные функции  и наивного баеса 
7. в примечаниях, где я привожу исключительный случай, указать ссылку на код и более подробно описать ошибку
(solve) 8. Привести сравнение результатов loo для parsenwindow при разных ядрах
(solve) 3. Отличия Парзеновского окна с переменным шагом от Парзеновскоого окна с постоянным шагом
10. Парзеновское окно не то же самое что и kNN, потому что если мы возьмем 100 объектов, лежащих рядом с исследуемым объектом, то их вес будет одинаков в Парзене , а в kNN - нет.
11. маржа должна зависеть от конкретного алгоритма
4. линейный классификатор
4. сравнение преимущества методов в таблице
улучшить функцию отрисовки

инвалидная скорость выполнения
paint.r - помойка (дублирование функций с незначительными изменениями), нужно сократить!! + добавить параметры в вызываемую функцию отрисовки
main.cpp
tmp.r - это подсказка для paint.r , пока его не переделаю

!!!!!!мне осталось только МПФ + СТОЛП + красиво оформить график с Margin 
(пока только кривую нарисовал), и еще улучшу все эти алгоритмы (kNN, ...) до O(ln(N))

1. че делать с плотностью?
2. как создать список функций
3. V(h) lambda_y (l_y) как их вычислять?


ggplot
maintain aspect ratio


Метод "парзеновского окна" с K(z)=1/2 , при |z|<=1 тоже самое что и kNN с w(i,u)=const
Метод "парзеновского окна" с K(z)!=const тоже самое что и kwNN, где w(i,u)!=const
Эти алгоритмы принципиально различаются только в одном: в kNN мы неявно задаем h (ширину окна) через k,
а в "парзеновском окне", наоборот, - мы неявно задаем k через h.
в kNN полагается p(u,x_i)=1
ф-ция расстояния p(u,x_i) это частный случай весовой ф-ции w(i,u)


oma(НИЗ, ЛЕВО, ВВЕРХ, ВПРАВО) - отступы от окна plot наружу
xjust - смещаем влево если положительное число на размер окна легенды по X
yjust - смещаем вниз если положительное число на размер окна легенды по Y

inset - смещает легенду относительно точи, которая задается текстово, например так "topleft"
если текст состоит из top/bottom или left/right то inset=const, причем
const отвечает соответственно за y или за x
если есть, например "topleft" или "rightbottom" то уже inset=c(const1,const2)
если отрицательное знач для:
1) x - двигаемся влево
2) y - двигаемся вверх
для положительного значения наоборот
для inset и xjust/yjust шаг в 1 равен расстоянию графика plot или legend соответственно





## Примечания
___
`3` алгоритма ведут себя одинаково при `k<40`,
только алгоритм Парзеновского окна с h=const начинает экспоненциально ошибаться с ростом `h`

На картинке "`parsenWindowFix_hOpt`" видно, что `LOO(h)` очень быстро стремится к `1`

При построении алгоритма `STOLP` возник 1 нюанс: когда мы проходимся по объектам,
на которых алгоритм a допускает ошибку, и считаем для них отступы, может оказаться что
они все `> 0` и не произойдет добавления нового эл. `x_i` к `Omega`. Для решения этой проблемы
была введена дополнительная переменная `delta(=0 по default)`, которую мы используем при
проверке отступов и увеличиваем на небольшую константу.

Метод "парзеновского окна" с `K(z)=1/2` , при `|z|<=1` тоже самое что и kNN с `w(i,u)=const`

Метод "парзеновского окна" с `K(z)!=const` тоже самое что и kwNN, где `w(i,u)!=const`

Эти алгоритмы принципиально различаются только в одном: в kNN мы неявно задаем `h` (ширину окна) через `k`,
а в "парзеновском окне", наоборот, - мы неявно задаем `k` через `h`.

в kNN полагается `p(u,x_i)=1`

ф-ция расстояния `p(u,x_i)` это частный случай весовой ф-ции `w(i,u)`
