(solve) 1. loo для алгоритма до и после применения к нему STOLP
2. добавить пример кода в ридми
(solve) 3. Отличия Парзеновского окна с переменным шагом от Парзеновскоого окна с постоянным шагом
4. сравнение преимущества методов в таблице
(solve )5. подбор карты, на которой будет явно видно преимущество kwNN над kNN
6. убрать "Я" из кода
7. в примечаниях, где я привожу исключительный случай, указать ссылку на код и более подробно описать ошибку
(solve) 8. Привести сравнение результатов loo для parsenwindow при разных ядрах
9. Добавить столбец, в таблицу, где будет отображено loo для каждого алгоритма
10. Парзеновское окно не то же самое что и kNN, потому что если мы возьмем 100 объектов, лежащих рядом с исследуемым объектом, то их вес будет одинаков в Парзене , а в kNN - нет.
11. маржа должна зависеть от конкретного алгоритма
12. добавить потенциальные функции  и наивного баеса с линейным классификатором
13. уменьшить размер картинок и добавить обтикание через alt параметры

инвалидная скорость выполнения
paint.r - помойка (дублирование функций с незначительными изменениями), нужно сократить!! + добавить параметры в вызываемую функцию отрисовки
main.cpp
tmp.r - это подсказка для paint.r , пока его не переделаю

!!!!!!мне осталось только МПФ + СТОЛП + красиво оформить график с Margin 
(пока только кривую нарисовал), и еще улучшу все эти алгоритмы (kNN, ...) до O(ln(N))

1. че делать с плотностью?
2. как создать список функций
3. V(h) lambda_y (l_y) как их вычислять?


ggplot
maintain aspect ratio


Метод "парзеновского окна" с K(z)=1/2 , при |z|<=1 тоже самое что и kNN с w(i,u)=const
Метод "парзеновского окна" с K(z)!=const тоже самое что и kwNN, где w(i,u)!=const
Эти алгоритмы принципиально различаются только в одном: в kNN мы неявно задаем h (ширину окна) через k,
а в "парзеновском окне", наоборот, - мы неявно задаем k через h.
в kNN полагается p(u,x_i)=1
ф-ция расстояния p(u,x_i) это частный случай весовой ф-ции w(i,u)


oma(НИЗ, ЛЕВО, ВВЕРХ, ВПРАВО) - отступы от окна plot наружу
xjust - смещаем влево если положительное число на размер окна легенды по X
yjust - смещаем вниз если положительное число на размер окна легенды по Y

inset - смещает легенду относительно точи, которая задается текстово, например так "topleft"
если текст состоит из top/bottom или left/right то inset=const, причем
const отвечает соответственно за y или за x
если есть, например "topleft" или "rightbottom" то уже inset=c(const1,const2)
если отрицательное знач для:
1) x - двигаемся влево
2) y - двигаемся вверх
для положительного значения наоборот
для inset и xjust/yjust шаг в 1 равен расстоянию графика plot или legend соответственно